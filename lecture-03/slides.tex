\documentclass{beamer}
% Tests as Prompt: A Test-Driven-Development Benchmark for LLM Code Generation
% https://blog.yfzhou.fyi/posts/tdd-llm/

\mode<presentation>
{
  \usetheme{CambridgeUS}
	\usecolortheme{beaver}
  % or ...

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}


\usepackage{xeCJK}
\usepackage{ulem}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{pifont}
\usepackage{biblatex}
\usepackage{bibentry}
\usepackage{verbatim}
\usepackage{listings}
\bibliography{cite}
\usepackage[absolute,overlay]{textpos}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\setCJKmainfont{WenQuanYi Micro Hei}
\renewcommand{\raggedright}{\leftskip=0pt \rightskip=0pt plus 0cm}
\raggedright

\let\oldfootnotesize\footnotesize
\renewcommand*{\footnotesize}{\oldfootnotesize\tiny}

\title[Intelligent Software Engineering] 
{Intelligent Software Engineering}
\subtitle{Dependency Management and Implementation}

\author[Zhilei Ren] 
{Zhilei Ren}

\institute[Dalian University of Technology] % (optional, but mostly needed)
{
\\\includegraphics[width=0.1\textwidth]{../utils/logo.png}\\
Dalian University of Technology
}


\subject{Software Engineering}



\pgfdeclareimage[width=0.08\textwidth]{university-logo}{../utils/logo.png}
\logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSection[]
{
  \begin{frame}<beamer>{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}

\setbeamertemplate{section in toc}[circle]
\setbeamertemplate{items}[circle]
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{bibliography item}{\insertbiblabel}
\setbeamertemplate{bibliography entry title}{}
\setbeamertemplate{bibliography entry journal}{}

% PlantUML listing configuration
\lstdefinestyle{plantuml}{
    language=Java,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white!95!black},
    frame=single,
    rulecolor=\color{black},
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showstringspaces=false
}

\lstdefinestyle{code}{
    basicstyle=\ttfamily\tiny,
    backgroundcolor=\color{white!95!black},
    frame=single,
    rulecolor=\color{black},
    breaklines=true,
    captionpos=b
}
\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Outline}
  \tableofcontents[currentsection,currentsubsection, 
    sectionstyle=show,
    subsectionstyle=show,
]
\end{frame}

\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}
\section{Introduction}
\begin{frame}[t]{The Two Paths of Software Implementation}
\begin{itemize}
\item \textbf{Third-Party Integration}: Leverage existing libraries and frameworks
\item \textbf{Custom Implementation}: Build functionality from scratch
\item Both approaches require sophisticated tool support
\item Modern development blends both strategies strategically
\end{itemize}

\begin{figure}
\includegraphics[width=0.6\textwidth]{images/Buy-vs.-Build.jpg}
\caption{Third-party vs custom implementation spectrum}
\end{figure}
\end{frame}

\begin{frame}[t]{Dependency Management: The Integration Path}
\begin{itemize}
\item \textbf{Challenge}: Managing external code dependencies and versions
\item \textbf{Tools}: Maven, npm, pip, Gradle, NuGet
\item \textbf{Key Activities}:
  \begin{itemize}
  \item Version conflict resolution
  \item Security vulnerability monitoring
  \item License compliance checking
  \item Build reproducibility assurance
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t]{Dependency Management: The Integration Path}
\begin{itemize}
\item \textbf{Benefit}: Accelerated development through reuse
\item \textbf{Risk}: Technical debt and security exposure
\end{itemize}
    \begin{figure}
        \includegraphics[width=0.3\textwidth]{images/dependency.png}
        \caption{Dependency Risk}
    \end{figure}
\end{frame}


\begin{frame}[t]{Code Generation: The Implementation Path}
\begin{itemize}
\item \textbf{Challenge}: Efficiently writing and maintaining custom code
\item \textbf{Tools}: LLM assistants, IDE completions, code generators
\item \textbf{Key Activities}:
  \begin{itemize}
  \item Intelligent code completion
  \item API implementation generation
  \item Boilerplate code automation
  \item Refactoring assistance
  \end{itemize}
\end{itemize}
\end{frame}
\begin{frame}[t]{Code Generation: The Implementation Path}
\begin{itemize}
\item \textbf{Benefit}: Control and customization
\item \textbf{Risk}: Implementation complexity and maintenance burden
\end{itemize}
    \begin{figure}
        \includegraphics[width=0.5\textwidth]{images/266-ai-app-gen.png}
        \caption{AI Assistant}
    \end{figure}
\end{frame}


\begin{frame}[t]{Strategic Decision Framework}
\begin{itemize}
\item \textbf{Choose Dependency When}:
  \begin{itemize}
  \item Functionality is well-established and stable
  \item Security and maintenance are handled by active community
  \item Core competency is elsewhere
  \end{itemize}
\item \textbf{Choose Custom Implementation When}:
  \begin{itemize}
  \item Functionality is a core competitive advantage
  \item Special requirements not met by existing solutions
  \item Long-term control and customization are critical
  \end{itemize}
\item \textbf{Modern Reality}: Most projects use a hybrid approach
\end{itemize}

\end{frame}

\section{Dependency Management}
\begin{frame}[t]{What is Dependency Management?}
Dependency management is the process of \textbf{managing external libraries, packages, and modules} that your software project relies on to function properly.

\bigskip

\textbf{Key aspects}:
\begin{itemize}
\item Identifying required dependencies
\item Specifying version constraints
\item Resolving conflicts between dependencies
\item Ensuring reproducible builds
\item Managing transitive dependencies
\end{itemize}

\bigskip

\begin{alertblock}{Importance}
Poor dependency management can lead to \textbf{build failures, security vulnerabilities, and maintenance nightmares}.
\end{alertblock}
\end{frame}

\subsection{Package Managers}

\begin{frame}[t]{Package Managers Overview}
Package managers automate the process of \textbf{installing, upgrading, configuring, and removing software packages}.

\bigskip

\textbf{Common package managers by ecosystem}:
\begin{itemize}
\item \textbf{System}: apt, yum, pacman, Homebrew
\item \textbf{Python}: pip, conda, Poetry
\item \textbf{JavaScript}: npm, yarn, pnpm
\item \textbf{Java}: Maven, Gradle
\item \textbf{Ruby}: gem, Bundler
\item \textbf{Rust}: Cargo
\end{itemize}

\bigskip

Each maintains a \textbf{central repository} of packages with versioning and dependency information.
\end{frame}

\begin{frame}[t]{APT - Advanced Package Tool}
APT is the package management system used by \textbf{Debian and Ubuntu-based Linux distributions}.

\bigskip

\textbf{Key commands}:
\begin{itemize}
\item \texttt{apt update}: Refresh package lists
\item \texttt{apt install <package>}: Install a package
\item \texttt{apt remove <package>}: Remove a package
\item \texttt{apt upgrade}: Upgrade all packages
\item \texttt{apt-cache depends <package>}: Show dependencies
\end{itemize}

\bigskip

APT uses \textbf{Debian packages (.deb)} with metadata describing dependencies, conflicts, and recommendations.
\end{frame}

\subsection{Dependency Visualization}

\begin{frame}[t,fragile]{Visualizing Dependencies with Debtree}
Debtree is a tool that \textbf{generates dependency graphs} for Debian packages, helping understand complex dependency relationships.

\bigskip

\textbf{Basic usage}:
\begin{verbatim}
debtree package-name | dot -Tpng > deps.png
\end{verbatim}

\bigskip

\textbf{Benefits of visualization}:
\begin{itemize}
\item Identify \textbf{circular dependencies}
\item Understand \textbf{transitive dependency chains}
\item Spot \textbf{unnecessary or redundant dependencies}
\item Analyze \textbf{impact of package updates}
\end{itemize}

\end{frame}

\begin{frame}[t,fragile]
    \frametitle{Dependency for nano}

    \tiny
    \begin{verbatim}
digraph "nano" {
        rankdir=LR;
        node [shape=box];
        "nano" -> "libncursesw6" [color=blue,label="(>= 6)"];
        "libncursesw6" -> "libtinfo6" [color=blue,label="(= 6.4+20240113-1ubuntu2)"];
        "libncursesw6" -> "libgpm2";
        "nano" -> "libtinfo6" [color=blue,label="(>= 6)"];
        "nano" -> "pico" [color=red];
        "nano" [style="setlinewidth(2)"]
        "pico" [style=filled,fillcolor=oldlace];
}
\end{verbatim}
    
    \begin{figure}
    \begin{center}
        \includegraphics[width=.5\textwidth]{images/nano.pdf}
    \end{center}
    \caption{debtree nano | dot -T pdf > nano.pdf}
    \end{figure}
    
\end{frame}

\begin{frame}[t]
    \frametitle{Dependency for vim}

    
    \begin{figure}
    \begin{center}
        \includegraphics[width=.8\textwidth]{images/vim.pdf}
    \end{center}
    \caption{debtree vim | dot -T pdf > vim.pdf}
    \end{figure}
    
\end{frame}
\subsection{Dependency Resolution}

\begin{frame}[t]{Dependency Resolution Challenges}
Dependency resolution is a \textbf{complex constraint satisfaction problem} that involves:

\bigskip

\textbf{Common challenges}:
\begin{itemize}
\item \textbf{Version conflicts}: Incompatible version requirements
\item \textbf{Diamond dependency problem}: Multiple paths to same package
\item \textbf{Circular dependencies}: A depends on B depends on A
\item \textbf{Platform-specific dependencies}: Different requirements per OS
\item \textbf{Optional dependencies}: Features that may or may not be needed
\end{itemize}

\bigskip

Modern package managers use \textbf{SAT/SMT/ILP solvers} to efficiently resolve these constraints.
\end{frame}

\begin{frame}[t]{Introduction to Z3 Theorem Prover}
Z3 is a \textbf{high-performance theorem prover} developed by Microsoft Research. It's used for:
\begin{itemize}
\scriptsize
\item \textbf{Constraint solving} and satisfiability checking
\item \textbf{Software verification} and program analysis
\item \textbf{Dependency resolution} and configuration management
\item \textbf{Symbolic execution} and test case generation
\end{itemize}

\bigskip

\textbf{Key features}:
\begin{itemize}
\scriptsize
\item Supports \textbf{multiple theories} (arithmetic, arrays, bit-vectors, etc.)
\item Provides \textbf{Python, C++, Java, and .NET APIs}
\item Used in production by Microsoft, Amazon, NASA, and others
\item Can solve \textbf{complex logical constraints} efficiently
\end{itemize}
\end{frame}

\begin{frame}[t]{Classic Example: Chicken-Rabbit Problem}

% \begin{block}{Problem Statement}
%     \begin{itemize}
%         \item 今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？
%         \item There are chickens and rabbits in the same cage. The total number of heads is 35, and the total number of feet is 94. How many chickens and rabbits are there?
%         \item From 孙子算经 (Sunzi Suanjing, 3rd to 5th centuries CE)
%     \begin{itemize}
% \end{block}
\begin{block}{Problem Statement}
\begin{itemize}
    \item 今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？
    \item There are chickens and rabbits in the same cage. The total number of heads is 35, and the total number of feet is 94. How many chickens and rabbits are there?
    \item From 孙子算经 (Mathematical Classic of Master Sun, around the 3rd-5th century AD)
\end{itemize}
\end{block}

\textbf{Mathematical formulation}:
\begin{itemize}
\item Let $c$ = number of chickens, $r$ = number of rabbits
\item Constraints: $c + r = 35$ (heads) and $2c + 4r = 94$ (feet)
\item Domain: $c \geq 0$, $r \geq 0$, integers
\end{itemize}
    \begin{textblock}{3}(12,3)
        \only<2>{
            \includegraphics[width=\textwidth]{images/Sun_Zi_Suanjing.jpg}
        }
    \end{textblock}

\end{frame}

\begin{frame}[t,fragile]{Classic Example: Chicken-Rabbit Problem}

\begin{block}{Imperative Problem Solving}
    \scriptsize
\begin{itemize}
    \item 上置三十五头，下置九十四足。半其足，得四十七。以少减多。
    \item Place 35 heads above and 94 feet below.  Take half of the feet, which is 47.  Then subtract the smaller number from the larger one.
\end{itemize}

\end{block}

\scriptsize
\begin{verbatim}
num_heads = 35
num_feet = 94
num_feet_half = num_feet // 2
num_rabbits = num_feet_half - num_heads
num_chicken = num_heads - num_rabbits
\end{verbatim}

\end{frame}

\begin{frame}[fragile,t]{Solving Chicken-Rabbit Problem with Z3}
    \begin{block}{Declarative Problem Solving}
        \scriptsize
        \begin{itemize}
            \item \textbf{What vs How}: Focus on describing \textit{what} the problem is rather than \textit{how} to solve it
            \item \textbf{Separation of Concerns}: Separate problem specification from solution algorithm
            \item \textbf{Examples}: SQL, Prolog, Answer Set Programming
        \end{itemize}
    \end{block}
\scriptsize
    \begin{verbatim}
import z3
chicken, rabbits = z3.Ints('chicken rabbits')
z3.solve(chicken >= 1,   # number of chicken
      rabbits >= 1,      # number of rabbits
      chicken + rabbits == 35,
      chicken * 2 + rabbits * 4 == 94)
\end{verbatim}
\end{frame}

\begin{frame}[t]{Z3 Solution and Historical Context}

\textbf{Connection to dependency resolution}:
\begin{itemize}
\item Similar to resolving \textbf{version constraints} and \textbf{conflicts}
\item Demonstrates how Z3 handles \textbf{integer constraints} and \textbf{equations}
\item Shows the \textbf{pattern} for encoding real-world problems as constraints
\end{itemize}

This ancient problem illustrates the \textbf{fundamental principles} that modern SAT solvers like Z3 use for dependency resolution.
\end{frame}

\begin{frame}[fragile,t]{Encoding Dependencies to Z3}
\begin{figure}
    \includegraphics[width=.3\textwidth]{images/dependency-graph.png}
\end{figure}

\scriptsize
\begin{verbatim}
import z3
A, B, C, D = z3.Bools("A B C D")
p1, p2, p3, p4, p5, p6 = z3.Bools("p1 p2 p3 p4 p5 p6")
solver = z3.Solver()
solver.assert_and_track(-1 * z3.If(A, 1, 0) + z3.If(B, 1, 0) >= 0, p1)
solver.assert_and_track(-1 * z3.If(A, 1, 0) + z3.If(C, 1, 0) >= 0, p2)
solver.assert_and_track(-1 * z3.If(A, 1, 0) + z3.If(D, 1, 0) >= 0, p3)
solver.assert_and_track(-1 * z3.If(B, 1, 0) + z3.If(D, 1, 0) >= 0, p4)
solver.assert_and_track(z3.If(C, 1, 0) + z3.If(D, 1, 0) <= 1, p5)
solver.assert_and_track(A == True, p6)

print(solver.check())
print(solver.unsat_core())

\end{verbatim}
\end{frame}


\subsection{Dependency Graphs in Practice}

\begin{frame}[t]{Real-World Dependency Complexity}
Modern software projects often have \textbf{complex dependency graphs} with hundreds or thousands of packages.

\bigskip

\textbf{Statistics from large projects}:
\begin{itemize}
\item Average npm package: 75+ dependencies
\item Typical web application: 1000+ transitive dependencies
\item Debian: 50,000+ packages with complex inter-dependencies
\end{itemize}

\bigskip

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{images/52-npm-delivery.png}
\caption{Complex dependency for modern web application}
\end{figure}
\end{frame}

\begin{frame}[t]{Dependency Vulnerabilities}
Dependencies can introduce \textbf{security vulnerabilities} that affect your application.

\bigskip

\textbf{Common issues}:
\begin{itemize}
\item Using outdated packages with known vulnerabilities
\item Transitive dependencies with security issues
\item Malicious packages in public repositories
\item License compliance violations
\end{itemize}

% \bigskip
% 
% \textbf{Mitigation strategies}:
% \begin{itemize}
% \item Regular \textbf{dependency scanning} (Snyk, Dependabot)
% \item \textbf{Software Bill of Materials} (SBOM) generation
% \item \textbf{Pinpoint versioning} and regular updates
% \item \textbf{Vulnerability databases} monitoring
% \end{itemize}
\end{frame}

\begin{frame}[t]
\frametitle{The Log4Shell Vulnerability (CVE-2021-44228)}

\begin{alertblock}{What is Log4Shell?}
\begin{itemize}
        \scriptsize
    \item A critical zero-day vulnerability discovered in December 2021.
    \item Affects Log4j, a popular, ubiquitous Java logging library.
    \item Affected thousands of applications and services globally, including those from major cloud providers and enterprise software vendors.
\end{itemize}
\end{alertblock}
\begin{figure}
    \includegraphics[width=0.5\textwidth]{images/log4j.png}
    \caption{How Log4Shell Works}
\end{figure}

\end{frame}
\subsection{Best Practices}

\begin{frame}[t]{Dependency Management Best Practices}
\textbf{Version specification}:
\begin{itemize}
\item Use \textbf{semantic versioning} (SemVer)
\item Prefer \textbf{pinned versions} in production
\item Implement \textbf{version ranges} carefully
\item Maintain \textbf{lock files} for reproducibility
\end{itemize}

\bigskip

% \textbf{Security practices}:
% \begin{itemize}
% \item Regular \textbf{dependency updates}
% \item \textbf{Automated vulnerability scanning}
% \item \textbf{Minimal dependency principle}
% \item \textbf{Multi-factor authentication} for package publishing
% \end{itemize}

\bigskip

\textbf{Development workflow}:
\begin{itemize}
\item \textbf{CI/CD integration} for dependency checks
\item \textbf{Peer review} for new dependencies
\item \textbf{Documentation} of dependency choices
\end{itemize}
\end{frame}

\begin{frame}[t]{Modern Tools and Techniques}
% \textbf{Emerging approaches}:
% \begin{itemize}
% \item \textbf{Dependabot}: Automated dependency updates
% \item \textbf{Renovate}: Multi-language dependency management
% \item \textbf{Software Composition Analysis} (SCA) tools
% \item \textbf{SBOM standards} (SPDX, CycloneDX)
% \end{itemize}

\bigskip

\textbf{Advanced techniques}:
\begin{itemize}
\item \textbf{Dependency vendoring}: Including dependencies in source
\item \textbf{Reproducible builds}: Ensuring consistent artifacts
\item \textbf{Supply chain security}: Verifying package integrity
\item \textbf{AI-assisted dependency resolution}
\end{itemize}

\bigskip

\begin{block}{Future Trends}
Increased focus on \textbf{software supply chain security} and \textbf{automated dependency maintenance}.
\end{block}
\end{frame}

\subsection{Conclusion}

\begin{frame}[t]{Key Takeaways}
\begin{itemize}
\item Dependency management is \textbf{essential for modern software development}
\item Package managers like \textbf{apt automate dependency resolution}
\item Tools like \textbf{debtree help visualize complex dependency graphs}
\item \textbf{SAT solvers like Z3} can encode and solve dependency constraints
\item \textbf{Security and maintenance} are critical aspects of dependency management
\item \textbf{Best practices and automation} reduce risks and overhead
\end{itemize}

\bigskip

\begin{alertblock}{Remember}
Every dependency is a \textbf{potential point of failure} - choose and manage them wisely!
\end{alertblock}
\end{frame}

\begin{frame}[t]{Vibe Coding}
    Vibe coding is an artificial intelligence-assisted software development style popularized by Andrej Karpathy in February 2025. The term was listed in the Merriam-Webster Dictionary the following month as a ``slang \& trending'' term. It describes a chatbot-based approach to creating software where the developer describes a project or task to a large language model (LLM), which generates code based on the prompt. The developer evaluates the result and asks the LLM for improvements. Unlike traditional AI-assisted coding or pair programming, the human developer avoids micromanaging the code, accepts AI-suggested completions liberally, and focuses more on iterative experimentation than code correctness or structure\footnote{\url{https://en.wikipedia.org/wiki/Vibe_coding}}.
\end{frame}

\begin{frame}[t]{The Illusion of AI Productivity}
    \centering
\includegraphics[width=.5\textwidth]{images/before_ai.jpeg} 
\end{frame}

\section{AI-Assisted Implementation}
\begin{frame}[t]{Intelligent Software Engineering}
\begin{itemize}
\item \textbf{Beyond Traditional Methods}: AI and optimization techniques in software development
\item \textbf{Multiple Approaches}: Different intelligent methods for different problems
\item \textbf{Complementary Strengths}: Each method excels in specific domains
\item \textbf{Practical Applications}: Real-world tools and techniques used today
\item \textbf{Human-AI Collaboration}: Augmenting developer capabilities
\end{itemize}
\end{frame}

\subsection{AI Pair Programming}

\begin{frame}[t]{What is AI Pair Programming?}
    \begin{block}{Definition}
        AI Pair Programming is a software development practice where developers collaborate with AI assistants to write code, receiving real-time suggestions, reviews, and optimizations.
    \end{block}
    
    \begin{columns}
        \begin{column}{0.6\textwidth}
            \textbf{Key Characteristics:}
            \begin{itemize}
                \item \textbf{Real-time Collaboration}: AI provides instant code suggestions
                \item \textbf{Knowledge Sharing}: AI transfers best practices and patterns
                \item \textbf{Quality Assurance}: Immediate code review and optimization
                \item \textbf{Learning Acceleration}: Opportunity for beginners to learn from experts
            \end{itemize}
        \end{column}
        \begin{column}{0.4\textwidth}
            \centering
            \includegraphics[width=0.9\textwidth]{images/ai-pair-programming.png}
            % \captionof{figure}{AI Pair Programming Concept}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[t]
    \frametitle{What is Extreme Programming?}
    
    \begin{block}{Core Idea}
        Extreme Programming (XP) is an agile software development methodology designed to improve software quality and responsiveness to changing customer requirements. It emphasizes adaptability over predictability.
    \end{block}
    
    \begin{alertblock}{Key Characteristics}
        \begin{itemize}
            \item Embraces requirement changes, even late in the development cycle.
            \item Promotes frequent releases in short development cycles.
            \item Intended to improve productivity and introduce checkpoints where new customer requirements can be adopted.
        \end{itemize}
    \end{alertblock}
    
\end{frame}

% Slide 2: Core Values and Practices
\begin{frame}[t]
    \frametitle{Core Values and Practices}
    
    \textbf{Five Core Values}
    \begin{itemize}
            \scriptsize
        \item \textbf{Communication}: Constant flow of information within the team and with the customer.
        \item \textbf{Simplicity}: Focus on the simplest solution that works today.
        \item \textbf{Feedback}: Rapid feedback loops from the system, customer, and team.
        \item \textbf{Courage}: To refactor code, throw away obsolete code, and adapt to changes.
        \item \textbf{Respect}: Among all team members, recognizing each contribution.
    \end{itemize}
    
    \vspace{0.5cm}
    \textbf{Selected Core Practices}
    \begin{itemize}
            \scriptsize
        \item \textbf{Test-Driven Development (TDD)}: Write tests before code.
        \item \textbf{Pair Programming}: Two programmers work together at one workstation.
        \item \textbf{Continuous Integration}: Integrate and test code multiple times a day.
    \end{itemize}
    
\end{frame}

% Slide 3: A Key Practice: Test-Driven Development
\begin{frame}[fragile, t] % 'fragile' option is used for the verbatim environment
    \frametitle{Practice in Focus: Test-Driven Development (TDD)}
    
    TDD is a relies on a very short, repetitive cycle:
    
    \begin{enumerate}
            \scriptsize
        \item Write a failing \textbf{automated test case}.
        \item Write the minimal \textbf{code} to make the test pass.
        \item \textbf{Refactor} the code to improve its structure.
    \end{enumerate}
    
    \begin{exampleblock}{Benefit}
        \scriptsize
        This cycle ensures nearly 100\% test coverage and helps create a simple, robust design. The tests act as a safety net for future changes.
    \end{exampleblock}
    
    \begin{figure}
        \includegraphics[width=0.3\textwidth]{images/applied-tdd.png}
        \caption{Applied TDD}
    \end{figure}
    
\end{frame}

\begin{frame}[t]
    \frametitle{Pair Programming: Two Heads, One Keyboard}
    
    \begin{block}{What is Pair Programming?}
        \small
        A core XP practice where \textbf{two programmers} work together at \textbf{one workstation}. One acts as the \textbf{Driver} (writing code) while the other serves as the \textbf{Navigator/Observer} (reviewing code and thinking strategically).
    \end{block}
    
    \begin{columns}
        \begin{column}{0.48\textwidth}
            \textbf{Roles}
            \begin{itemize}
                    \small
                \item \textbf{Driver}: Hands on keyboard, focuses on tactical implementation
                \item \textbf{Navigator}: Strategic thinker, reviews each line, considers alternatives
                \item \textbf{Roles switch frequently} (every 30-60 minutes)
            \end{itemize}
        \end{column}
        \begin{column}{0.48\textwidth}
            \centering
            \begin{figure}
            \begin{center}
                \includegraphics[width=0.7\linewidth]{images/pair.png}
            \end{center}
            \caption{Pair Programming Setup}
            \end{figure}
            
        \end{column}
    \end{columns}

    
    
\end{frame}

\begin{frame}[t]{Pair Programming}
    \begin{alertblock}{Key Benefits}
        \begin{itemize}
                \scriptsize
            \item \textbf{Higher Code Quality}: Continuous code review reduces defects
            \item \textbf{Knowledge Sharing}: Prevents knowledge silos and "bus factor"
            \item \textbf{Better Design}: More discussion leads to better solutions
            \item \textbf{Training}: Junior developers learn from seniors naturally
        \end{itemize}
    \end{alertblock}
    \begin{figure}
    \begin{center}
        \includegraphics[width=0.3\linewidth]{images/pair-programming.jpeg}
    \end{center}
    \caption{Actual Case}
    \end{figure}
    
    
\end{frame}
\begin{frame}[t]{Traditional vs. AI Pair Programming}
    \begin{table}
        \centering
        \scriptsize
        \begin{tabular}{p{0.3\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}}
            \textbf{Aspect} & \textbf{Traditional} & \textbf{AI Pair Programming} \\
            \hline
            Availability & Requires another developer & Available 24/7 \\
            Knowledge & Limited to developers' experience & Vast best practices coverage \\
            Consistency & Varies by individuals & Highly consistent standards \\
            Cost & Two developers' time & Lower tool costs \\
            Learning & Bidirectional knowledge transfer & Primarily learning from AI \\
            Creativity & Mutual brainstorming & Pattern-based suggestions \\
        \end{tabular}
        \caption{Comparison of Pair Programming Approaches}
    \end{table}
\end{frame}

\begin{frame}[t]{Popular AI Pair Programming Tools}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \textbf{IDE-Integrated Tools:}
            \begin{itemize}
                \item \textbf{GitHub Copilot}
                \begin{itemize}
                    \item Most popular AI programming assistant
                    \item Multi-language support
                    \item Context-aware code generation
                \end{itemize}
                
                \item \textbf{Amazon CodeWhisperer}
                \begin{itemize}
                    \item AWS-optimized integration
                    \item Security scanning features
                    \item Free for individual use
                \end{itemize}
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            \textbf{Other Tools:}
            \begin{itemize}
                \item \textbf{Tabnine}
                \begin{itemize}
                    \item On-premise deployment options
                    \item Privacy-focused
                \end{itemize}
                
                \item \textbf{Cursor}
                \begin{itemize}
                    \item AI-first code editor
                    \item Deep code understanding
                \end{itemize}
                
                \item \textbf{Replit AI}
                \begin{itemize}
                    \item Cloud development environment
                    \item Real-time collaboration
                \end{itemize}
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

%%%%% \begin{frame}[t,fragile]{AI Pair Programming Workflow}
%%%%%     \begin{lstlisting}[style=code, caption={Typical AI Pair Programming Interaction}]
%%%%% // Developer: Write function signature
%%%%% function calculateTax(income: number, deductions: number): number {
%%%%%     // Developer: Add comment describing requirements
%%%%%     // Calculate tax based on income and deductions
%%%%%     // Use progressive tax brackets
%%%%%     
%%%%%     // AI Assistant: Auto-generates implementation
%%%%%     const taxableIncome = income - deductions;
%%%%%     
%%%%%     if (taxableIncome <= 0) return 0;
%%%%%     
%%%%%     const brackets = [
%%%%%         { limit: 10000, rate: 0.1 },
%%%%%         { limit: 40000, rate: 0.2 },
%%%%%         { limit: Infinity, rate: 0.3 }
%%%%%     ];
%%%%%     
%%%%%     let tax = 0;
%%%%%     let previousLimit = 0;
%%%%%     
%%%%%     for (const bracket of brackets) {
%%%%%         if (taxableIncome > previousLimit) {
%%%%%             const amountInBracket = Math.min(
%%%%%                 taxableIncome - previousLimit, 
%%%%%                 bracket.limit - previousLimit
%%%%%             );
%%%%%             tax += amountInBracket * bracket.rate;
%%%%%             previousLimit = bracket.limit;
%%%%%         }
%%%%%     }
%%%%%     
%%%%%     return tax;
%%%%% }
%%%%%     \end{lstlisting}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{AI Pair Programming in Requirements Engineering}
%%%%%     \begin{block}{Bridging Requirements and Code}
%%%%%         AI Pair Programming helps transform requirements specifications directly into executable code
%%%%%     \end{block}
%%%%%     
%%%%%     \textbf{Specific Applications:}
%%%%%     \begin{itemize}
%%%%%         \item \textbf{Requirements Prototyping}: Quick conversion of requirements to working prototypes
%%%%%         \item \textbf{Specification Validation}: Verify requirement feasibility through code
%%%%%         \item \textbf{Test Case Generation}: Auto-generate test code from requirements
%%%%%         \item \textbf{API Design}: Generate code frameworks from interface requirements
%%%%%         \item \textbf{Database Design}: Convert data requirements to SQL schemas
%%%%%     \end{itemize}
%%%%%     
%%%%%     \begin{exampleblock}{Example Workflow}
%%%%%         Requirements Document → AI Understanding → Code Framework → Iterative Refinement → Final Implementation
%%%%%     \end{exampleblock}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t,fragile]{Requirements-to-Code Transformation Example}
%%%%%     \begin{columns}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{Requirements Specification:}
%%%%%             \begin{lstlisting}[style=code]
%%%%% User Requirements:
%%%%% - User registration
%%%%% - Email verification
%%%%% - Password strength check
%%%%% - Welcome email sending
%%%%% 
%%%%% Business Rules:
%%%%% - Password minimum 8 chars
%%%%% - Mixed case and numbers
%%%%% - Unique email required
%%%%% - Verification code valid 10min
%%%%%             \end{lstlisting}
%%%%%         \end{column}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{AI-Generated Code Framework:}
%%%%%             \begin{lstlisting}[style=code]
%%%%% // User registration service
%%%%% class UserService {
%%%%%     async register(userData) {
%%%%%         // Validate email uniqueness
%%%%%         // Check password strength
%%%%%         // Create user record
%%%%%         // Send verification email
%%%%%         // Return success response
%%%%%     }
%%%%%     
%%%%%     isStrongPassword(password) {
%%%%%         // Check length >= 8
%%%%%         // Check uppercase/lowercase
%%%%%         // Check contains number
%%%%%     }
%%%%% }
%%%%%             \end{lstlisting}
%%%%%         \end{column}
%%%%%     \end{columns}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Best Practices for Students}
%%%%%     \begin{columns}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{Effective Patterns:}
%%%%%             \begin{enumerate}
%%%%%                 \item \textbf{Clear Intent}: Write descriptive comments
%%%%%                 \item \textbf{Incremental Development}: Small steps, frequent validation
%%%%%                 \item \textbf{Code Review}: Critically evaluate AI suggestions
%%%%%                 \item \textbf{Test-Driven}: Write tests first, then generate code
%%%%%                 \item \textbf{Security First}: Validate security and edge cases
%%%%%             \end{enumerate}
%%%%%         \end{column}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{Pitfalls to Avoid:}
%%%%%             \begin{itemize}
%%%%%                 \item \textbf{Blind Acceptance}: Not reviewing AI-generated code
%%%%%                 \item \textbf{Over-reliance}: Losing programming thinking skills
%%%%%                 \item \textbf{Security Risks}: Ignoring security reviews
%%%%%                 \item \textbf{Copyright Issues}: Using protected code
%%%%%                 \item \textbf{Performance Neglect}: Skipping performance testing
%%%%%             \end{itemize}
%%%%%         \end{column}
%%%%%     \end{columns}
%%%%%     
%%%%%     \vspace{0.5cm}
%%%%%     \textbf{Quality Assurance Process:}
%%%%%     \begin{enumerate}
%%%%%         \item AI suggests code → 2. Student reviews → 3. Run tests → 4. Integrate to codebase
%%%%%     \end{enumerate}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t,fragile]{Test-Driven AI Pair Programming}
%%%%%     \begin{block}{Test-First Development}
%%%%%         Write test cases first, then use AI to generate implementation code that passes the tests
%%%%%     \end{block}
%%%%%     
%%%%%     \begin{columns}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{Test Cases Example:}
%%%%%             \begin{lstlisting}[style=code]
%%%%% // Write tests first
%%%%% describe('Tax Calculator', () => {
%%%%%     test('calculates tax correctly', () => {
%%%%%         expect(calculateTax(50000, 5000))
%%%%%             .toBe(8500);
%%%%%     });
%%%%%     
%%%%%     test('handles zero income', () => {
%%%%%         expect(calculateTax(0, 1000))
%%%%%             .toBe(0);
%%%%%     });
%%%%% });
%%%%%             \end{lstlisting}
%%%%%         \end{column}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{AI Generates Implementation:}
%%%%%             \begin{lstlisting}[style=code]
%%%%% // AI implements based on tests
%%%%% function calculateTax(income, deductions) {
%%%%%     // Implementation logic...
%%%%%     // Must pass all test cases
%%%%% }
%%%%%             \end{lstlisting}
%%%%%         \end{column}
%%%%%     \end{columns}
%%%%%     
%%%%%     \textbf{Benefits for Learning:}
%%%%%     \begin{itemize}
%%%%%         \item Ensures code meets requirements
%%%%%         \item Automatic validation of correctness
%%%%%         \item Facilitates regression testing
%%%%%         \item Improves code quality awareness
%%%%%     \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t,fragile]{Effective Prompt Engineering for Students}
%%%%%     \begin{lstlisting}[style=code, caption={Structured Prompt Template}]
%%%%% // Poor prompt:
%%%%% "write a sorting function"
%%%%% 
%%%%% // Effective prompt:
%%%%% """
%%%%% Act as an experienced JavaScript developer. 
%%%%% Help me implement a quicksort function.
%%%%% 
%%%%% Requirements:
%%%%% - Function name: quickSort
%%%%% - Parameters: array (numbers)
%%%%% - Returns: new sorted array
%%%%% - Use recursive implementation with comments
%%%%% 
%%%%% Example input: [3, 1, 4, 1, 5, 9, 2, 6]
%%%%% Expected output: [1, 1, 2, 3, 4, 5, 6, 9]
%%%%% 
%%%%% Please explain the algorithm approach first, 
%%%%% then provide the code implementation.
%%%%% """
%%%%%     \end{lstlisting}
%%%%%     
%%%%%     \textbf{Prompt Engineering Tips:}
%%%%%     \begin{itemize}
%%%%%         \item Specify role and context clearly
%%%%%         \item Include specific technical requirements
%%%%%         \item Provide input/output examples
%%%%%         \item Define code standards and constraints
%%%%%         \item Request step-by-step explanations
%%%%%     \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Learning Benefits for Students}
%%%%%     \begin{columns}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{Technical Skills:}
%%%%%             \begin{itemize}
%%%%%                 \item \textbf{Faster Learning}: 2-3x acceleration in skill acquisition
%%%%%                 \item \textbf{Best Practices}: Exposure to professional coding standards
%%%%%                 \item \textbf{Pattern Recognition}: Learn common algorithms and patterns
%%%%%                 \item \textbf{Debugging Skills}: See how AI approaches problem-solving
%%%%%                 \item \textbf{Code Quality}: Understand what makes code maintainable
%%%%%             \end{itemize}
%%%%%         \end{column}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{Professional Development:}
%%%%%             \begin{itemize}
%%%%%                 \item \textbf{Confidence Building}: Quick success with complex tasks
%%%%%                 \item \textbf{Portfolio Growth}: Ability to complete more projects
%%%%%                 \item \textbf{Industry Preparation}: Learn tools used in professional environments
%%%%%                 \item \textbf{Collaboration Skills}: Practice code review and collaboration
%%%%%                 \item \textbf{Problem Decomposition}: Learn to break down complex problems
%%%%%             \end{itemize}
%%%%%         \end{column}
%%%%%     \end{columns}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Common Challenges for Student Developers}
%%%%%     \begin{columns}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{Technical Challenges:}
%%%%%             \begin{itemize}
%%%%%                 \item \textbf{Understanding Limitations}: When AI suggestions are wrong
%%%%%                 \item \textbf{Over-complex Solutions}: AI may suggest advanced patterns
%%%%%                 \item \textbf{Dependency Management}: Handling library recommendations
%%%%%                 \item \textbf{Debugging AI Code}: Tracing issues in generated code
%%%%%                 \item \textbf{Performance Awareness}: Recognizing inefficient solutions
%%%%%             \end{itemize}
%%%%%         \end{column}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{Learning Challenges:}
%%%%%             \begin{itemize}
%%%%%                 \item \textbf{Skill Dependency}: Risk of relying too much on AI
%%%%%                 \item \textbf{Conceptual Gaps}: Missing fundamental understanding
%%%%%                 \item \textbf{Critical Thinking}: Need to evaluate AI suggestions
%%%%%                 \item \textbf{Academic Integrity}: Proper use in coursework
%%%%%                 \item \textbf{Balance Finding}: When to use AI vs. manual coding
%%%%%             \end{itemize}
%%%%%         \end{column}
%%%%%     \end{columns}
%%%%%     
%%%%%     \vspace{0.5cm}
%%%%%     \textbf{Strategies for Success:}
%%%%%     \begin{itemize}
%%%%%         \item Use AI for learning, not just completing assignments
%%%%%         \item Always review and understand AI-generated code
%%%%%         \item Practice manual coding regularly
%%%%%         \item Discuss AI suggestions with instructors
%%%%%         \item Document what you learn from each interaction
%%%%%     \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Academic Integrity Considerations}
%%%%%     \begin{block}{Responsible Use in Education}
%%%%%         AI Pair Programming should enhance learning, not replace it
%%%%%     \end{block}
%%%%%     
%%%%%     \textbf{Institutional Guidelines:}
%%%%%     \begin{itemize}
%%%%%         \item \textbf{Check Course Policies}: Understand what's allowed in each course
%%%%%         \item \textbf{Transparency}: Disclose AI assistance in submissions
%%%%%         \item \textbf{Learning Focus}: Use AI to understand, not just complete work
%%%%%         \item \textbf{Proper Attribution}: Credit AI contributions appropriately
%%%%%     \end{itemize}
%%%%%     
%%%%%     \textbf{Recommended Practices:}
%%%%%     \begin{itemize}
%%%%%         \item Use AI for learning concepts, not assignment completion
%%%%%         \item Document your learning process with AI
%%%%%         \item Show both AI suggestions and your modifications
%%%%%         \item Discuss AI interactions in code comments
%%%%%         \item Focus on understanding the underlying concepts
%%%%%     \end{itemize}
%%%%%     
%%%%%     \begin{alertblock}{Important}
%%%%%         Always follow your institution's academic integrity policies regarding AI tool usage
%%%%%     \end{alertblock}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Practical Exercise: Student Project Workflow}
%%%%%     \textbf{Step-by-Step Learning Approach:}
%%%%%     
%%%%%     \begin{enumerate}
%%%%%         \item \textbf{Requirements Analysis}: Use AI to understand project requirements
%%%%%         \item \textbf{Design Phase}: Get AI suggestions for architecture and patterns
%%%%%         \item \textbf{Implementation}: Use AI for code generation with active learning
%%%%%         \item \textbf{Testing}: Generate test cases and learn testing strategies
%%%%%         \item \textbf{Review}: Use AI for code review and optimization suggestions
%%%%%         \item \textbf{Reflection}: Document what you learned from the AI interactions
%%%%%     \end{enumerate}
%%%%%     
%%%%%     \textbf{Learning Objectives:}
%%%%%     \begin{itemize}
%%%%%         \item Understand how to translate requirements to code
%%%%%         \item Learn professional coding standards and patterns
%%%%%         \item Develop critical evaluation skills for code quality
%%%%%         \item Practice iterative development and refinement
%%%%%         \item Build confidence in tackling complex programming tasks
%%%%%     \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t,fragile]{Sample Student Project: Todo List Application}
%%%%%     \begin{columns}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{Requirements:}
%%%%%             \begin{lstlisting}[style=code]
%%%%% Create a todo list app with:
%%%%% - Add new tasks
%%%%% - Mark tasks complete
%%%%% - Delete tasks
%%%%% - Filter tasks (all/active/completed)
%%%%% - Local storage persistence
%%%%% - Responsive design
%%%%%             \end{lstlisting}
%%%%%         \end{column}
%%%%%         \begin{column}{0.5\textwidth}
%%%%%             \textbf{AI-Assisted Learning:}
%%%%%             \begin{itemize}
%%%%%                 \item Get HTML/CSS structure suggestions
%%%%%                 \item Learn JavaScript event handling
%%%%%                 \item Understand local storage API
%%%%%                 \item Study responsive design patterns
%%%%%                 \item Practice code organization
%%%%%             \end{itemize}
%%%%%         \end{column}
%%%%%     \end{columns}
%%%%%     
%%%%%     \vspace{0.5cm}
%%%%%     \textbf{Learning Outcomes:}
%%%%%     \begin{itemize}
%%%%%         \item DOM manipulation techniques
%%%%%         \item State management patterns
%%%%%         \item Data persistence methods
%%%%%         \item UI/UX design considerations
%%%%%         \item Problem decomposition skills
%%%%%     \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Future Career Preparation}
%%%%%     \begin{block}{Industry Relevance}
%%%%%         AI Pair Programming skills are increasingly valuable in professional software development
%%%%%     \end{block}
%%%%%     
%%%%%     \textbf{Career Benefits:}
%%%%%     \begin{itemize}
%%%%%         \item \textbf{Technical Adaptability}: Experience with modern development tools
%%%%%         \item \textbf{Efficiency Skills}: Ability to work effectively with AI assistants
%%%%%         \item \textbf{Quality Mindset}: Understanding of code quality standards
%%%%%         \item \textbf{Collaboration Experience}: Practice with AI-human teamwork
%%%%%         \item \textbf{Continuous Learning}: Comfort with evolving technology tools
%%%%%     \end{itemize}
%%%%%     
%%%%%     \textbf{Industry Trends:}
%%%%%     \begin{itemize}
%%%%%         \item AI assistance becoming standard in development environments
%%%%%         \item Growing demand for developers who can work effectively with AI
%%%%%         \item Increased focus on code quality and maintainability
%%%%%         \item Emphasis on rapid prototyping and iteration
%%%%%         \item Importance of clear communication and requirements understanding
%%%%%     \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Getting Started: Student Action Plan}
%%%%%     \textbf{Immediate Steps:}
%%%%%     \begin{enumerate}
%%%%%         \item \textbf{Choose a Tool}: Start with GitHub Copilot (student discount available)
%%%%%         \item \textbf{Small Projects}: Begin with simple coding exercises
%%%%%         \item \textbf{Active Learning}: Always understand the code AI generates
%%%%%         \item \textbf{Document Learning}: Keep notes on patterns and techniques learned
%%%%%         \item \textbf{Seek Feedback}: Discuss AI interactions with instructors and peers
%%%%%     \end{enumerate}
%%%%%     
%%%%%     \textbf{Learning Resources:}
%%%%%     \begin{itemize}
%%%%%         \item GitHub Education Pack (free access to developer tools)
%%%%%         \item Online tutorials on effective prompt engineering
%%%%%         \item University coding clubs and workshops
%%%%%         \item Open source projects for practice
%%%%%         \item Peer programming sessions with AI discussion
%%%%%     \end{itemize}
%%%%%     
%%%%%     \begin{exampleblock}{Call to Action}
%%%%%         Start experimenting with AI Pair Programming in your next coding project! Focus on using it as a learning tool to enhance your understanding, not just complete assignments.
%%%%%     \end{exampleblock}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Summary: AI as Learning Partner}
%%%%%     \begin{columns}
%%%%%         \begin{column}{0.6\textwidth}
%%%%%             \textbf{Key Takeaways:}
%%%%%             \begin{itemize}
%%%%%                 \item AI Pair Programming accelerates learning when used intentionally
%%%%%                 \item Critical thinking and code review skills remain essential
%%%%%                 \item Balance AI assistance with fundamental skill development
%%%%%                 \item Focus on understanding concepts, not just completing work
%%%%%                 \item Document and reflect on your learning journey
%%%%%             \end{itemize}
%%%%%         \end{column}
%%%%%         \begin{column}{0.4\textwidth}
%%%%%             \centering
%%%%%             \includegraphics[width=0.9\textwidth]{images/ai-learning-partner.png}
%%%%%             % \captionof{figure}{AI as Learning Enhancement}
%%%%%         \end{column}
%%%%%     \end{columns}
%%%%%     
%%%%%     \vspace{0.5cm}
%%%%%     \begin{block}{Successful Approach}
%%%%%         The most effective students use AI as a tutor and collaborator, not a crutch. They maintain active engagement, ask questions, and focus on deep understanding.
%%%%%     \end{block}
%%%%% \end{frame}

\subsection{How AI-Assisted Programming Works Under the Hood}

\begin{frame}[t]
    \frametitle{Introduction to AI-Assisted Programming}
    
    \begin{block}{What is AI-Assisted Programming?}
        AI-assisted programming uses artificial intelligence, particularly Large Language Models (LLMs), to help developers with various coding tasks, from code completion to full project generation .
    \end{block}
    
    \begin{alertblock}{The Fundamental Shift}
        \begin{itemize}
            \item Traditional programming: Writing detailed instructions (how)
            \item AI-assisted programming: Describing desired outcomes (what) 
            \item This represents a move from \textbf{instruction-based} to \textbf{intent-based} programming 
        \end{itemize}
    \end{alertblock}
    
    \begin{exampleblock}{Key Benefit}
        ``The major benefit of AI in coding is reducing the search time by a lot, taking over routine chores, producing code drafts immediately''.
    \end{exampleblock}
    
\end{frame}

% Slide 2: Core Technical Architecture
\begin{frame}[t]
    \frametitle{Core Technical Architecture}
    
    AI-assisted programming systems typically consist of several interconnected layers:
    
    \begin{block}{Layered Architecture}
        \begin{enumerate}
            \scriptsize
            \item \textbf{Brain \& Cognitive Core}: Powerful LLMs (GPT-4, Claude, Gemini) for code generation and reasoning
            \item \textbf{Agentic Frameworks}: Systems for planning, tool use, and self-correction
            \item \textbf{Execution Environment}: Safe sandboxed environments for code execution
            \item \textbf{Knowledge Base}: RAG systems for project-specific context
        \end{enumerate}
    \end{block}
    % https://venturebeat.com/ai/agentic-ai-a-deep-dive-into-the-future-of-automation 
    \begin{figure}
        \includegraphics[width=0.5\linewidth]{images/agentic.png}
        \caption{AI-Assisted Programming System Architecture}
    \end{figure}
    
\end{frame}

% Slide 3: The Agentic Workflow - Planning and Execution
% \begin{frame}[t]
%     \frametitle{The Agentic Workflow: Planning and Execution}
%     
%     \begin{block}{AI Agent = LLM + Planning + Tools}
%         \begin{itemize}
%             \item \textbf{LLM}: The cognitive core for understanding and reasoning
%             \item \textbf{Planning}: Decomposing complex goals into manageable steps
%             \item \textbf{Tools}: External APIs and functions the AI can use
%         \end{itemize}
%     \end{block}
%     
%     \begin{exampleblock}{ReAct Pattern: Reason + Act}
%         AI agents follow an iterative loop:
%         \begin{enumerate}
%             \item \textbf{Reason}: Analyze what to do next
%             \item \textbf{Act}: Execute chosen action (code, call API, etc.)
%             \item \textbf{Observe}: Analyze results and repeat
%         \end{enumerate}
%     \end{exampleblock}
%     
%     \begin{alertblock}{Tool Use Capabilities}
%         Agents can interact with file systems, version control, APIs, browsers, and execution environments.
%     \end{alertblock}
%     
% \end{frame}

% Slide 4: Human-AI Collaboration in Practice
\begin{frame}[t]
    \frametitle{Human-AI Collaboration in Practice}
    
    \begin{block}{Professional AI Programming Workflow}
        \begin{enumerate}
            \item \textbf{Context Preparation}: Provide all relevant project information
            \item \textbf{Strategy First}: Discuss approaches before coding
            \item \textbf{Select \& Draft}: Choose best approach, then generate code
            \item \textbf{Review \& Learn}: Critical examination and understanding
            \item \textbf{Test \& Iterate}: Verify and refine
        \end{enumerate}
    \end{block}
    
    \begin{alertblock}{The ``70\% Problem''}
        AI excels at routine, pattern-based work (70\% of coding tasks), but the remaining 30\% - edge cases, architecture, and maintainability - still requires human expertise.
    \end{alertblock}
    
\end{frame}

% Slide 5: Challenges and Best Practices
\begin{frame}[t]
    \frametitle{Challenges and Best Practices}
    
    \begin{block}{Key Challenges}
        \begin{itemize}
            \scriptsize
            \item \textbf{AI Hallucinations}: Confident but incorrect outputs
            \item \textbf{Security \& Privacy}: Potential vulnerabilities in generated code
            \item \textbf{Intellectual Property}: Copyright concerns with training data
            \item \textbf{Demo-Quality Trap}: Code that works in demo but fails in production
        \end{itemize}
    \end{block}
    
    \begin{exampleblock}{Best Practices}
        \begin{itemize}
            \scriptsize
            \item \textbf{Trust but Verify}: Never blindly trust AI-generated code
            \item \textbf{Iterate and Review}: Treat AI output as drafts requiring human review
            \item \textbf{Maintain Oversight}: Humans must remain ``in the loop'' for critical decisions
            \item \textbf{Continuous Testing}: Comprehensive testing is more crucial than ever
        \end{itemize}
    \end{exampleblock}
    
\end{frame}

\begin{frame}[t]{Challenges and Best Practices}

    \begin{figure}
        \includegraphics[width=.8\textwidth]{images/col-llm.pdf}
        \caption{Test-Driven Development with LLMs}
    \end{figure}
\end{frame}


% \begin{frame}[t]{Code Embeddings: Representing Code Semantically}
%     \begin{block}{Learning Code Representations}
%         Models create dense vector representations that capture code semantics.
%     \end{block}
%     
%     \textbf{Embedding Techniques:}
%     \begin{itemize}
%         \item \textbf{Token Embeddings}: Represent individual tokens
%         \item \textbf{Positional Embeddings}: Encode token positions
%         \item \textbf{Type Embeddings}: Distinguish tokens by type (keyword, variable, etc.)
%         \item \textbf{Contextual Embeddings}: Vary based on surrounding context
%     \end{itemize}
%     
%     \begin{columns}[t]
%         \begin{column}{0.6\textwidth}
%             \textbf{Semantic Code Similarity:}
%             \begin{itemize}
%                 \item Similar code snippets have similar embeddings
%                 \item Enables code search and recommendation
%                 \item Helps with code completion and bug detection
%             \end{itemize}
%             
%             \textbf{Example:}
%             \texttt{for i in range(10):} and \texttt{for j in range(10):} have similar embeddings despite different variable names.
%         \end{column}
%         \begin{column}{0.4\textwidth}
%             \centering
%             \includegraphics[width=0.9\textwidth]{example-image} % {images/code-embeddings.png}
%             % \captionof{figure}{Code Embedding Space}
%         \end{column}
%     \end{columns}
% \end{frame}
% 
% \begin{frame}[t]{Integration with Development Environments}
%     \begin{block}{Seamless Developer Experience}
%         AI assistance is integrated into IDEs through various mechanisms.
%     \end{block}
%     
%     \textbf{Integration Components:}
%     \begin{itemize}
%         \item \textbf{Language Server Protocol (LSP)}: Standardized IDE integration
%         \item \textbf{Background Analysis}: Continuous code analysis
%         \item \textbf{Real-time Suggestions}: As-you-type code completion
%         \item \textbf{Context Awareness}: Understanding project structure
%     \end{itemize}
%     
%     \begin{columns}[t]
%         \begin{column}{0.5\textwidth}
%             \textbf{IDE Integration Architecture:}
%             \begin{enumerate}
%                 \item Developer writes code
%                 \item IDE sends context to AI service
%                 \item AI model generates suggestions
%                 \item Suggestions filtered and ranked
%                 \item Displayed in IDE interface
%             \end{enumerate}
%         \end{column}
%         \begin{column}{0.5\textwidth}
%             \textbf{Performance Considerations:}
%             \begin{itemize}
%                 \item Latency requirements (<100ms for completions)
%                 \item Caching frequently used suggestions
%                 \item Batch processing for multiple suggestions
%                 \item Model quantization for faster inference
%             \end{itemize}
%         \end{column}
%     \end{columns}
% \end{frame}
% 
\begin{frame}[t]{Limitations and Challenges}
    \begin{block}{Current Technical Limitations}
        \scriptsize
        Understanding limitations helps use AI programming tools effectively.
    \end{block}
    
    \begin{columns}[t]
        \begin{column}{0.5\textwidth}
            \textbf{Technical Challenges:}
            \begin{itemize}
                \scriptsize
                \item \textbf{Context Length}: Limited understanding of large codebases
                \item \textbf{Reasoning Depth}: Difficulty with complex logic chains
                \item \textbf{API Knowledge}: May not know latest libraries
                \item \textbf{Security}: Potential for suggesting vulnerable code
                \item \textbf{Performance}: May suggest inefficient algorithms
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            \textbf{Fundamental Limitations:}
            \begin{itemize}
                \scriptsize
                \item \textbf{No True Understanding}: Pattern matching, not reasoning
                \item \textbf{Training Data Bias}: Reflects biases in training data
                \item \textbf{Lack of Creativity}: Cannot invent truly novel solutions
                \item \textbf{No Intent Understanding}: Doesn't understand why code is needed
                \item \textbf{Error Propagation}: Can amplify mistakes from training data
            \end{itemize}
        \end{column}
    \end{columns}
    
    \begin{alertblock}{Important Distinction}
        \scriptsize
        AI programming assistants are powerful tools, but they lack true understanding of code semantics and requirements.
    \end{alertblock}
\end{frame}

\begin{frame}[t]{Future Directions in AI-Assisted Programming}
    \begin{block}{Emerging Research Areas}
        The field is rapidly evolving with several promising directions.
    \end{block}
    
    \textbf{Research Frontiers:}
    \begin{itemize}
            \scriptsize
        \item \textbf{Larger Context Windows}: Handling entire codebases
        \item \textbf{Better Reasoning}: Improved logical reasoning capabilities
        \item \textbf{Multimodal Understanding}: Combining code, docs, and diagrams
        \item \textbf{Personalization}: Adapting to individual coding styles
        \item \textbf{Verification Integration}: Formal verification of generated code
    \end{itemize}
    
    \begin{columns}[t]
        \begin{column}{0.5\textwidth}
            \textbf{Architecture Innovations:}
            \begin{itemize}
                    \scriptsize
                \item \textbf{Retrieval-Augmented Generation}: Combining with code search
                \item \textbf{Program Synthesis}: Generating code from specifications
                \item \textbf{Neuro-symbolic Approaches}: Combining neural and symbolic AI
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            \textbf{Application Areas:}
            \begin{itemize}
                    \scriptsize
                \item \textbf{Automated Refactoring}: Intelligent code improvement
                \item \textbf{Code Migration}: Porting between languages/frameworks
                \item \textbf{Accessibility}: Helping developers with disabilities
                \item \textbf{Education}: Personalized programming tutoring
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\subsection{Advanced Components: Function Calling}

\begin{frame}[t]{Function Calling: Structured AI Interactions}
    \begin{block}{Beyond Text Generation}
        Function calling allows AI models to interact with external tools and APIs in a structured way.
    \end{block}
    
    \textbf{What is Function Calling?}
    \begin{itemize}
        \scriptsize
        \item Standardized way for models to request execution of specific functions
        \item Returns structured data instead of unstructured text
        \item Enables tool usage, API calls, and code execution
        \item Critical for reliable AI-assisted programming
    \end{itemize}
    
    \begin{columns}[t]
        \begin{column}{0.5\textwidth}
            \textbf{Traditional Approach:}
            \begin{itemize}
                \scriptsize
                \item Model generates text instructions
                \item Human interprets and executes
                \item Error-prone and slow
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            \textbf{Function Calling Approach:}
            \begin{itemize}
                \scriptsize
                \item Model requests specific function
                \item System executes automatically
                \item Structured, reliable results
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile, t]
  \frametitle{Python + Ollama Example}
  \tiny
\begin{verbatim}
import ollama

def add_two_numbers(a: int, b: int) -> int:
    """
    Add two numbers
    Args:
      a: The first integer number
      b: The second integer number
    Returns:
      int: The sum of the two numbers
    """
    return a + b

response = ollama.chat(
  'llama3.1',
  messages=[{'role': 'user', 'content': 'What is 10 + 10?'}],
  tools=[add_two_numbers], # Actual function reference
)

available_functions = { 'add_two_numbers': add_two_numbers }

for tool in response.message.tool_calls or []:
    function_to_call = available_functions.get(tool.function.name)
    if function_to_call:
        print('Function output:', function_to_call(**tool.function.arguments))
    else:
        print('Function not found:', tool.function.name)
\end{verbatim}
\end{frame}

\begin{frame}[t]{How Function Calling Works Technically}
    \begin{block}{Architecture Overview}
        Function calling involves coordination between the AI model, function registry, and execution environment.
    \end{block}
    
    \textbf{Technical Flow:}
    \begin{enumerate}
        \scriptsize
        \item \textbf{Function Registration}: Available functions are defined with schemas
        \item \textbf{Model Decision}: AI decides when to call functions based on context
        \item \textbf{Structured Request}: Model outputs function call with parameters
        \item \textbf{Execution}: System executes the function with provided parameters
        \item \textbf{Result Integration}: Function results are fed back to the model
    \end{enumerate}

\end{frame}

    
\begin{frame}[t]{How Function Calling Works Technically}
    \begin{columns}[t]
        \begin{column}{0.5\textwidth}
            \textbf{Benefits:}
            \begin{itemize}
                \scriptsize
                \item \textbf{Reliability}: Structured data reduces errors
                \item \textbf{Safety}: Controlled execution environment
                \item \textbf{Efficiency}: Automated tool usage
                \item \textbf{Extensibility}: Easy to add new capabilities
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            \textbf{Challenges:}
            \begin{itemize}
                \scriptsize
                \item \textbf{Security}: Managing execution permissions
                \item \textbf{Error Handling}: Dealing with function failures
                \item \textbf{Latency}: Additional execution time
                \item \textbf{Complexity}: More moving parts to manage
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[t]
  \frametitle{Key Takeaways}
  \begin{itemize}
    \item LLM function calling bridges reasoning and execution.
    \item Ollama allows defining functions and passing them at runtime.
    \item Python integrates easily: capture function call → execute → return results.
    \item Extendable to databases, APIs, or custom tools.
  \end{itemize}
\end{frame}

% \begin{frame}[t,fragile]{Example: Function Calling for Code Refactoring}
%     \begin{block}{Real-world Workflow}
%         Function calling enables complex multi-step programming tasks.
%     \end{block}
%     
%     \begin{lstlisting}[style=code, basicstyle=\ttfamily\tiny]
% // User request: "Refactor this function to be more efficient"
% 
% // Step 1: AI analyzes the code and decides to call analysis functions
% {
%     "function_call": {
%         "name": "analyzeComplexity",
%         "parameters": {
%             "code": "function processData(data) {...}",
%             "metrics": ["cyclomatic", "cognitive"]
%         }
%     }
% }
% 
% // Step 2: System returns complexity analysis
% {
%     "cyclomatic_complexity": 8,
%     "cognitive_complexity": 12,
%     "suggestions": ["Extract helper functions", "Simplify conditionals"]
% }
% 
% // Step 3: AI generates refactored code and calls validation
% {
%     "function_call": {
%         "name": "validateRefactoring",
%         "parameters": {
%             "original": "function processData(data) {...}",
%             "refactored": "function processData(data) {...}",
%             "tests": "existing_test_suite"
%         }
%     }
% }
%     \end{lstlisting}
% \end{frame}

% \begin{frame}[t]{Introduction to Model Context Protocol (MCP)}
%     \begin{block}{Standardizing AI-Tool Interactions}
%         MCP is an emerging standard for how AI models interact with tools and external resources.
%     \end{block}
%     
%     \textbf{What is MCP?}
%     \begin{itemize}
%         \item \textbf{Standardized Protocol}: Common interface for tool integration
%         \item \textbf{Tool Discovery}: Models can discover available capabilities
%         \item \textbf{Structured Communication}: Well-defined request/response patterns
%         \item \textbf{Security Framework}: Controlled access to resources
%     \end{itemize}
%     
%     \textbf{Key Components of MCP:}
%     \begin{itemize}
%         \item \textbf{Resource Definitions}: How tools describe their capabilities
%         \item \textbf{Request Schemas}: Standardized way to make requests
%         \item \textbf{Response Formats}: Consistent data structures
%         \item \textbf{Error Handling}: Standard error codes and messages
%     \end{itemize}
%     
%     \begin{alertblock}{Industry Significance}
%         MCP is becoming the de facto standard for AI tool integration, similar to LSP for language servers.
%     \end{alertblock}
% \end{frame}
% 
% \begin{frame}[t]{MCP Architecture and Components}
%     \begin{block}{How MCP Works}
%         MCP provides a framework for tools to expose capabilities to AI models.
%     \end{block}
%     
%     \textbf{MCP Architecture Layers:}
%     \begin{enumerate}
%         \item \textbf{Transport Layer}: Communication protocol (HTTP, WebSockets, etc.)
%         \item \textbf{Message Format}: JSON-RPC or similar structured format
%         \item \textbf{Schema Definition}: OpenAPI-like tool descriptions
%         \item \textbf{Authentication}: Security and access control
%     \end{enumerate}
%     
%     \begin{columns}[t]
%         \begin{column}{0.5\textwidth}
%             \textbf{Server (Tool Provider):}
%             \begin{itemize}
%                 \item Exposes capabilities via MCP
%                 \item Defines available functions
%                 \item Handles authentication
%                 \item Manages resource access
%             \end{itemize}
%         \end{column}
%         \begin{column}{0.5\textwidth}
%             \textbf{Client (AI Model/Application):}
%             \begin{itemize}
%                 \item Discovers available tools
%                 \item Makes structured requests
%                 \item Handles responses
%                 \item Manages sessions
%             \end{itemize}
%         \end{column}
%     \end{columns}
%     
%     \textbf{Example MCP Tools in Programming:}
%     \begin{itemize}
%         \item Code analysis tools, build systems, package managers, testing frameworks
%     \end{itemize}
% \end{frame}
% 
% \begin{frame}[t,fragile]{MCP in Action: Programming Workflow}
%     \begin{block}{Practical MCP Implementation}
%         MCP enables sophisticated AI programming assistants with tool integration.
%     \end{block}
%     
%     \begin{lstlisting}[style=code, basicstyle=\ttfamily\tiny]
% // MCP Tool Registration
% {
%     "name": "code-analyzer",
%     "version": "1.0.0",
%     "capabilities": {
%         "functions": [
%             {
%                 "name": "staticAnalysis",
%                 "description": "Perform static code analysis",
%                 "parameters": {
%                     "code": {"type": "string"},
%                     "ruleset": {"type": "string", "optional": true}
%                 }
%             },
%             {
%                 "name": "complexityMetrics",
%                 "description": "Calculate code complexity metrics",
%                 "parameters": {
%                     "code": {"type": "string"},
%                     "metrics": {"type": "array"}
%                 }
%             }
%         ]
%     }
% }
% 
% // AI Model using MCP
% const response = await mcpClient.request("code-analyzer/staticAnalysis", {
%     code: userCode,
%     ruleset: "strict"
% });
%     \end{lstlisting}
% \end{frame}

% \begin{frame}[t]{Benefits of MCP for AI-Assisted Programming}
%     \begin{block}{Why MCP Matters}
%         MCP addresses key challenges in AI tool integration.
%     \end{block}
%     
%     \begin{columns}[t]
%         \begin{column}{0.5\textwidth}
%             \textbf{For Tool Developers:}
%             \begin{itemize}
%                 \item \textbf{Standardization}: One integration works with multiple AI systems
%                 \item \textbf{Discoverability}: Tools can be easily found and used
%                 \item \textbf{Maintenance}: Consistent update and versioning patterns
%                 \item \textbf{Security}: Built-in authentication and authorization
%             \end{itemize}
%         \end{column}
%         \begin{column}{0.5\textwidth}
%             \textbf{For AI System Developers:}
%             \begin{itemize}
%                 \item \textbf{Interoperability}: Consistent way to integrate tools
%                 \item \textbf{Extensibility}: Easy to add new capabilities
%                 \item \textbf{Reliability}: Standardized error handling
%                 \item \textbf{Performance}: Optimized communication patterns
%             \end{itemize}
%         \end{column}
%     \end{columns}
%     
%     \vspace{0.3cm}
%     \textbf{For End Users (Developers):}
%     \begin{itemize}
%         \item \textbf{Richer Experience}: More sophisticated AI assistance
%         \item \textbf{Consistent Behavior}: Predictable tool interactions
%         \item \textbf{Security}: Controlled access to sensitive operations
%         \item \textbf{Choice}: Ability to use preferred tools
%     \end{itemize}
% \end{frame}
% 
% \begin{frame}[t]{Function Calling + MCP: Powerful Combination}
%     \begin{block}{Integrated Architecture}
%         Function calling and MCP work together to create robust AI programming systems.
%     \end{block}
%     
%     \textbf{Combined Workflow:}
%     \begin{enumerate}
%         \item AI model processes user request and code context
%         \item Model identifies need for external tool usage
%         \item Through MCP, discovers available functions
%         \item Uses function calling to execute specific operations
%         \item Integrates results back into the response
%     \end{enumerate}
%     
%     \begin{columns}[t]
%         \begin{column}{0.5\textwidth}
%             \textbf{Example: Code Optimization}
%             \begin{itemize}
%                 \item User: "Optimize this sorting function"
%                 \item AI uses MCP to find performance analysis tools
%                 \item Calls functions to benchmark current implementation
%                 \item Generates optimized version based on results
%                 \item Validates optimization with testing tools
%             \end{itemize}
%         \end{column}
%         \begin{column}{0.5\textwidth}
%             \textbf{Example: Bug Fixing}
%             \begin{itemize}
%                 \item User: "Fix this runtime error"
%                 \item AI uses MCP to access debugging tools
%                 \item Calls functions to analyze stack traces
%                 \item Tests potential fixes with validation tools
%                 \item Provides fix with evidence of correctness
%             \end{itemize}
%         \end{column}
%     \end{columns}
% \end{frame}
% 
% \begin{frame}[t]{Real-world Examples and Implementations}
%     \begin{block}{Industry Adoption}
%         Major AI programming tools are adopting function calling and MCP.
%     \end{block}
%     
%     \textbf{OpenAI Function Calling:}
%     \begin{itemize}
%         \item Integrated into GPT-4 and later models
%         \item Allows models to call predefined functions
%         \item Used in GitHub Copilot for advanced features
%         \item Enables code execution, analysis, and validation
%     \end{itemize}
%     
%     \textbf{Anthropic's Tool Use:}
%     \begin{itemize}
%         \item Claude's equivalent to function calling
%         \item Integrated with various development tools
%         \item Supports complex multi-step programming tasks
%     \end{itemize}
%     
%     \textbf{Amazon CodeWhisperer:}
%     \begin{itemize}
%         \item Uses similar patterns for AWS service integration
%         \item Can call AWS APIs for infrastructure management
%         \item Integrated with security scanning tools
%     \end{itemize}
%     
%     \textbf{Open Source MCP Implementations:}
%     \begin{itemize}
%         \item Various MCP servers for different programming tools
%         \item Community-driven tool integrations
%         \item Extensible frameworks for custom integrations
%     \end{itemize}
% \end{frame}
% 
% \begin{frame}[t]{Security Considerations}
%     \begin{block}{Safe AI-Tool Interactions}
%         Function calling and MCP introduce important security considerations.
%     \end{block}
%     
%     \textbf{Security Challenges:}
%     \begin{itemize}
%         \item \textbf{Code Execution}: Preventing malicious code execution
%         \item \textbf{Data Exposure}: Protecting sensitive code and data
%         \item \textbf{Resource Abuse}: Preventing excessive resource usage
%         \item \textbf{Access Control}: Managing permissions appropriately
%     \end{itemize}
%     
%     \begin{columns}[t]
%         \begin{column}{0.5\textwidth}
%             \textbf{Security Measures:}
%             \begin{itemize}
%                 \item \textbf{Sandboxing}: Isolated execution environments
%                 \item \textbf{Authentication}: Verified tool identities
%                 \item \textbf{Authorization}: Role-based access control
%                 \item \textbf{Auditing}: Logging all tool interactions
%                 \item \textbf{Rate Limiting}: Preventing abuse
%             \end{itemize}
%         \end{column}
%         \begin{column}{0.5\textwidth}
%             \textbf{Best Practices:}
%             \begin{itemize}
%                 \item \textbf{Principle of Least Privilege}: Minimal required permissions
%                 \item \textbf{Input Validation}: Sanitizing all parameters
%                 \item \textbf{Output Sanitization}: Cleaning tool responses
%                 \item \textbf{Error Handling}: Safe failure modes
%                 \item \textbf{User Consent}: Confirming sensitive operations
%             \end{itemize}
%         \end{column}
%     \end{columns}
% \end{frame}
% 
% \begin{frame}[t]{Future Evolution of AI-Tool Integration}
%     \begin{block}{Where This Technology is Headed}
%         Function calling and MCP represent the beginning of sophisticated AI-tool integration.
%     \end{block}
%     
%     \textbf{Emerging Trends:}
%     \begin{itemize}
%         \item \textbf{Automatic Tool Discovery}: AI models finding and learning new tools
%         \item \textbf{Adaptive Interfaces}: Tools that customize based on AI capabilities
%         \item \textbf{Multi-Modal Integration}: Combining code, documentation, and visual tools
%         \item \textbf{Federated Learning}: Tools that improve through AI interactions
%     \end{itemize}
%     
%     \textbf{Research Directions:}
%     \begin{itemize}
%         \item \textbf{Intelligent Tool Selection}: AI choosing the right tools for tasks
%         \item \textbf{Compositional Tool Use}: Combining multiple tools for complex tasks
%         \item \textbf{Explainable Tool Interactions}: Understanding why AI chose specific tools
%         \item \textbf{Safe Tool Exploration}: Learning to use tools without causing harm
%     \end{itemize}
%     
%     \begin{alertblock}{Long-term Vision}
%         Future AI programming assistants will seamlessly integrate with the entire software development ecosystem, from idea to deployment.
%     \end{alertblock}
% \end{frame}

\begin{frame}[t]{Why Students Should Understand This}
    \begin{block}{Career-Relevant Knowledge}
        Understanding these concepts prepares students for the future of software development.
    \end{block}
    
    \textbf{Why This Matters for Students:}
    \begin{itemize}
            \scriptsize
        \item \textbf{Industry Standards}: These technologies are becoming standard in professional tools
        \item \textbf{System Design Skills}: Understanding distributed AI systems
        \item \textbf{API Design Knowledge}: Learning how to design AI-friendly interfaces
        \item \textbf{Security Awareness}: Understanding AI system security implications
    \end{itemize}
    
    \textbf{Learning Outcomes:}
    \begin{itemize}
            \scriptsize
        \item Understand how modern AI programming tools work internally
        \item Design systems that can integrate with AI assistants
        \item Evaluate AI tool capabilities and limitations
        \item Make informed decisions about AI tool adoption
    \end{itemize}
    
\end{frame}
\subsection{Future Directions}
\begin{frame}[t]{Emerging Trends in Intelligent Development}
\begin{itemize}
\item \textbf{Automated Design Synthesis}: From requirements to implementation
\item \textbf{Context-Aware Completion}: Understanding project-specific patterns
\item \textbf{Real-time Design Validation}: Continuous constraint checking
\item \textbf{Personalized Code Generation}: Adapting to individual coding styles
\item \textbf{Multi-modal Design Tools}: Combining code, diagrams, and specifications
\end{itemize}
\end{frame}

\subsection{Best Practices}
\begin{frame}[t]{Effective Intelligent Design Assistance}
\begin{itemize}
\item \textbf{Problem-Solution Fit}: Match method to design challenge characteristics
\item \textbf{Incremental Adoption}: Start with well-defined subproblems
\item \textbf{Validation Strategy}: Always verify intelligent system outputs
\item \textbf{Human Oversight}: Maintain designer control and understanding
\item \textbf{Documentation}: Record AI-assisted design decisions and rationale
\end{itemize}
\end{frame}

\begin{frame}[t]{Conclusion}
\begin{itemize}
\item \textbf{Rich Methodology}: Diverse intelligent approaches for software design
\item \textbf{Practical Value}: Accelerating and improving design decisions
\item \textbf{Complementary Nature}: Different methods excel at different tasks
\item \textbf{Human-Centric}: Augmenting rather than replacing designers
\item \textbf{Rapid Evolution}: Continuous improvement in intelligent assistance
\end{itemize}

\vspace{0.5cm}
\textbf{Key Insight}: Intelligent methods provide powerful assistance for complex software design and implementation challenges
\end{frame}

\begin{frame}[t]
\centering
\Huge{Thank You}
\vspace{1cm}
\normalsize
Questions?
\end{frame}


\end{document}

%%%%% \section{Intelligent Methods Overview}
%%%%% \begin{frame}[t]{Spectrum of Intelligent Approaches}
%%%%% \begin{itemize}
%%%%% \item \textbf{LLM-based Methods}: Natural language understanding and generation
%%%%% \item \textbf{Search-based Optimization}: Evolutionary algorithms and local search
%%%%% \item \textbf{Constraint Solving}: Formal methods and SAT solving
%%%%% \item \textbf{Hybrid Approaches}: Combining multiple intelligent techniques
%%%%% \item \textbf{Specialized AI}: Domain-specific machine learning models
%%%%% \end{itemize}
%%%%% \begin{figure}
%%%%% \includegraphics[width=0.6\textwidth]{example-image}
%%%%% \caption{Intelligent methods landscape in software engineering}
%%%%% \end{figure}
%%%%% \end{frame}
%%%%% 
%%%%% \section{Large Language Models (LLMs)}
%%%%% \begin{frame}[t]{LLM-based Approaches}
%%%%% \begin{itemize}
%%%%% \item \textbf{Foundation}: Transformer architecture trained on massive text/code corpora
%%%%% \item \textbf{Strengths}: Natural language understanding, code generation, documentation
%%%%% \item \textbf{Applications}: Code completion, architecture design, API generation
%%%%% \item \textbf{Examples}: GitHub Copilot, ChatGPT, CodeLlama
%%%%% \item \textbf{Limitations}: Hallucinations, lack of formal guarantees
%%%%% \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[fragile,t]{LLM Code Implementation Example}
%%%%% \begin{verbatim}
%%%%% // Prompt: "Implement a thread-safe LRU cache in Java"
%%%%% public class LRUCache<K, V> {
%%%%%     private final int capacity;
%%%%%     private final LinkedHashMap<K, V> cache;
%%%%%     
%%%%%     public LRUCache(int capacity) {
%%%%%         this.capacity = capacity;
%%%%%         this.cache = new LinkedHashMap<K, V>(
%%%%%             capacity, 0.75f, true) {
%%%%%             protected boolean removeEldestEntry(
%%%%%                 Map.Entry<K, V> eldest) {
%%%%%                 return size() > capacity;
%%%%%             }
%%%%%         };
%%%%%     }
%%%%%     // Additional methods implemented by LLM...
%%%%% }
%%%%% \end{verbatim}
%%%%% \end{frame}

%%%%% \section{Search-Based Software Engineering}
%%%%% \begin{frame}[t]{SBSE for Software Design and Implementation}
%%%%% \begin{itemize}
%%%%% \item \textbf{Foundation}: Treat software design as search problem in solution space
%%%%% \item \textbf{Strengths}: Finding optimal or near-optimal design solutions
%%%%% \item \textbf{Applications}: Algorithm selection, data structure optimization, code synthesis
%%%%% \item \textbf{Key Insight}: Software design decisions can be optimized systematically
%%%%% \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{SBSE for Algorithm Selection and Implementation}
%%%%% \begin{itemize}
%%%%% \item \textbf{Problem}: Choose optimal algorithm for specific problem constraints
%%%%% \item \textbf{Search Space}: Different algorithms and their parameterizations
%%%%% \item \textbf{Fitness Function}: Runtime complexity, memory usage, implementation complexity
%%%%% \item \textbf{Method}: Genetic algorithm exploring algorithm combinations
%%%%% \item \textbf{Result}: Best algorithm choice with optimized parameters
%%%%% \end{itemize}
%%%%% \begin{figure}
%%%%% \includegraphics[width=0.4\textwidth]{example-image}
%%%%% \caption{Algorithm selection search space}
%%%%% \end{figure}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[fragile,t]{SBSE for Data Structure Optimization}
%%%%% \begin{verbatim}
%%%%% // Problem: Optimize data structure for frequent insertions and rare lookups
%%%%% // Search-based approach explores different data structure implementations
%%%%% 
%%%%% // Candidate solutions explored:
%%%%% Solution 1: ArrayList with binary search (O(n) insert, O(log n) lookup)
%%%%% Solution 2: LinkedList (O(1) insert, O(n) lookup)  
%%%%% Solution 3: Balanced BST (O(log n) insert, O(log n) lookup)
%%%%% Solution 4: Hash table with lazy deletion (O(1) insert, O(1) lookup)
%%%%% 
%%%%% // Fitness evaluation based on actual usage patterns
%%%%% // Optimal solution selected: LinkedList for 90% insert-heavy workload
%%%%% \end{verbatim}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{SBSE for Code Synthesis and Completion}
%%%%% \begin{itemize}
%%%%% \item \textbf{Challenge}: Automatically complete partial code implementations
%%%%% \item \textbf{Approach}: Genetic programming with code fragments as building blocks
%%%%% \item \textbf{Fitness}: Type correctness, test case passing, code quality metrics
%%%%% \item \textbf{Application}: Auto-completing complex algorithmic implementations
%%%%% \item \textbf{Example}: Synthesizing efficient matrix operations from specifications
%%%%% \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[fragile,t]{SBSE for API Implementation Completion}
%%%%% \begin{verbatim}
%%%%% // Partial implementation provided by developer
%%%%% public interface DataProcessor {
%%%%%     Data process(Input input);
%%%%%     // Additional methods to be completed...
%%%%% }
%%%%% 
%%%%% // SBSE generates complete implementation based on usage patterns
%%%%% public class EfficientDataProcessor implements DataProcessor {
%%%%%     public Data process(Input input) { /* optimized */ }
%%%%%     public void validate(Data data) { /* auto-generated */ }
%%%%%     public Result batchProcess(List<Input> inputs) { /* synthesized */ }
%%%%%     // Additional methods synthesized by search-based approach
%%%%% }
%%%%% \end{verbatim}
%%%%% \end{frame}
%%%%% 
%%%%% \section{Constraint-Based Methods}
%%%%% \begin{frame}[t]{Constraint Solving for Software Design}
%%%%% \begin{itemize}
%%%%% \item \textbf{Foundation}: Encode design constraints as logical formulas
%%%%% \item \textbf{Strengths}: Guaranteed satisfaction of specified properties
%%%%% \item \textbf{Applications}: Type-driven synthesis, interface conformance, design patterns
%%%%% \item \textbf{Key Benefit}: Formal verification of design decisions
%%%%% \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Constraint-Based API Design and Implementation}
%%%%% \begin{itemize}
%%%%% \item \textbf{Problem}: Ensure API consistency and completeness
%%%%% \item \textbf{Constraints}: Method preconditions, postconditions, invariants
%%%%% \item \textbf{Method}: Enforce constraints during API evolution
%%%%% \item \textbf{Application}: Automated checking of API design rules
%%%%% \item \textbf{Benefit}: Early detection of design violations
%%%%% \end{itemize}
%%%%% \begin{figure}
%%%%% \includegraphics[width=0.5\textwidth]{example-image}
%%%%% \caption{Constraint-based API verification}
%%%%% \end{figure}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[fragile,t]{Constraint-Based Code Completion}
%%%%% \begin{verbatim}
%%%%% // Partial code with type constraints
%%%%% public <T> T process(List<T> items) {
%%%%%     // Constraint solver infers missing operations
%%%%%     // Constraints: T must support comparison, serialization
%%%%%     // Based on usage context and method signatures
%%%%%     
%%%%%     // Solution generated by constraint solver:
%%%%%     Collections.sort(items);  // T must implement Comparable
%%%%%     return serializer.serialize(items); // T must be serializable
%%%%% }
%%%%% 
%%%%% // Constraint solver ensures type safety and API consistency
%%%%% \end{verbatim}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Constraint-Based Design Pattern Implementation}
%%%%% \begin{itemize}
%%%%% \item \textbf{Objective}: Correctly implement design patterns with formal guarantees
%%%%% \item \textbf{Constraints}: Pattern-specific rules (Observer: subject-observer relationships)
%%%%% \item \textbf{Method}: Encode pattern constraints as logical formulas
%%%%% \item \textbf{Verification}: Check implementation against pattern constraints
%%%%% \item \textbf{Completion}: Suggest missing pattern elements
%%%%% \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[fragile,t]{Constraint-Based Singleton Pattern Enforcement}
%%%%% \begin{verbatim}
%%%%% // Constraint: Singleton class must have private constructor
%%%%% // and static getInstance method
%%%%% 
%%%%% class DatabaseConnection {
%%%%%     private static DatabaseConnection instance;
%%%%%     
%%%%%     // Constraint solver verifies:
%%%%%     // ✓ Constructor is private
%%%%%     // ✓ getInstance method exists and is static
%%%%%     // ✓ Instance variable is static
%%%%%     
%%%%%     private DatabaseConnection() {}  // Verified: private
%%%%%     public static DatabaseConnection getInstance() { // Verified: static
%%%%%         if (instance == null) {
%%%%%             instance = new DatabaseConnection();
%%%%%         }
%%%%%         return instance;
%%%%%     }
%%%%% }
%%%%% \end{verbatim}
%%%%% \end{frame}
%%%%% 
%%%%% \section{Natural Language Processing}
%%%%% \begin{frame}[t]{NLP for Design Specification Processing}
%%%%% \begin{itemize}
%%%%% \item \textbf{Foundation}: Extract design intent from natural language
%%%%% \item \textbf{Strengths}: Bridging requirement documents and implementation
%%%%% \item \textbf{Applications}: Design pattern recognition, architecture extraction
%%%%% \item \textbf{Evolution}: From manual analysis to automated understanding
%%%%% \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \section{Hybrid Approaches}
%%%%% \begin{frame}[t]{Combining Methods for Design and Implementation}
%%%%% \begin{itemize}
%%%%% \item \textbf{LLM + Constraints}: Generate code with formal verification
%%%%% \item \textbf{SBSE + Constraints}: Search with guaranteed constraint satisfaction
%%%%% \item \textbf{NLP + SBSE}: Extract design constraints for optimization
%%%%% \item \textbf{Multi-method Integration}: Comprehensive design assistance
%%%%% \end{itemize}
%%%%% \begin{figure}
%%%%% \includegraphics[width=0.5\textwidth]{example-image}
%%%%% \caption{Hybrid intelligent design system}
%%%%% \end{figure}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[fragile,t]{Hybrid Example: Intelligent Code Completion}
%%%%% \begin{verbatim}
%%%%% // Developer writes partial method:
%%%%% public String processData(String input) {
%%%%%     // Step 1: LLM suggests initial completion
%%%%%     if (input == null) return "";
%%%%%     String result = input.trim();
%%%%%     
%%%%%     // Step 2: Constraint solver verifies null safety
%%%%%     // ✓ input checked for null, ✓ return value not null
%%%%%     
%%%%%     // Step 3: SBSE optimizes string operations
%%%%%     // Replaces inefficient concatenation with StringBuilder
%%%%%     
%%%%%     // Step 4: Final verified and optimized code
%%%%%     StringBuilder sb = new StringBuilder();
%%%%%     sb.append(result.toLowerCase());
%%%%%     return sb.toString();
%%%%% }
%%%%% \end{verbatim}
%%%%% \end{frame}

%%%%% \subsection{Application Domains}
%%%%% \begin{frame}[t]{Software Design and Implementation}
%%%%% \begin{itemize}
%%%%% \item \textbf{LLMs}: Rapid prototyping and boilerplate generation
%%%%% \item \textbf{SBSE}: Optimal algorithm and data structure selection
%%%%% \item \textbf{Constraint-based}: Type-safe API design and implementation
%%%%% \item \textbf{Hybrid}: End-to-end design and implementation assistance
%%%%% \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Code Completion and Synthesis}
%%%%% \begin{itemize}
%%%%% \item \textbf{LLMs}: Context-aware code suggestions
%%%%% \item \textbf{SBSE}: Optimization-driven completion
%%%%% \item \textbf{Constraint-based}: Type-directed synthesis with guarantees
%%%%% \item \textbf{NLP}: Requirement-driven implementation
%%%%% \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Architecture and Pattern Implementation}
%%%%% \begin{itemize}
%%%%% \item \textbf{Constraint-based}: Formal pattern verification
%%%%% \item \textbf{SBSE}: Optimal pattern instantiation
%%%%% \item \textbf{LLMs}: Pattern explanation and examples
%%%%% \item \textbf{Hybrid}: Pattern-compliant architecture generation
%%%%% \end{itemize}
%%%%% \end{frame}

%%%%% \subsection{Comparative Analysis}
%%%%% \begin{frame}[t]{Method Comparison for Design/Implementation}
%%%%% \begin{center}
%%%%% \begin{tabular}{lccc}
%%%%% \textbf{Method} & \textbf{Correctness Guarantees} & \textbf{Creativity} & \textbf{Speed} \\
%%%%% \hline
%%%%% LLM-based & Low & High & Fast \\
%%%%% SBSE & Medium & Medium & Medium \\
%%%%% Constraint-based & High & Low & Slow \\
%%%%% Hybrid & High & High & Medium \\
%%%%% \end{tabular}
%%%%% \end{center}
%%%%% 
%%%%% \begin{itemize}
%%%%% \item \textbf{Correctness Guarantees}: Formal verification capabilities
%%%%% \item \textbf{Creativity}: Novel solution generation
%%%%% \item \textbf{Speed}: Response time for practical use
%%%%% \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \begin{frame}[t]{Strengths for Design and Implementation}
%%%%% \begin{itemize}
%%%%% \item \textbf{LLMs}: Excellent for exploratory design and rapid prototyping
%%%%% \item \textbf{SBSE}: Superior for optimization problems and algorithm selection
%%%%% \item \textbf{Constraint-based}: Unmatched for correctness-critical components
%%%%% \item \textbf{Hybrid}: Balanced approach for complex design challenges
%%%%% \end{itemize}
%%%%% \end{frame}
%%%%% 
%%%%% \subsection{Tools and Frameworks}
%%%%% \begin{frame}[t]{Design and Implementation Tools}
%%%%% \begin{itemize}
%%%%% \item \textbf{LLM-based}: GitHub Copilot, Amazon CodeWhisperer, Tabnine
%%%%% \item \textbf{SBSE}: Program synthesis tools (SKETCH, Rosette)
%%%%% \item \textbf{Constraint-based}: Z3 for program verification, Alloy for design
%%%%% \item \textbf{Hybrid}: Intelligent IDEs with multiple AI assistants
%%%%% \end{itemize}
%%%%% \end{frame}
